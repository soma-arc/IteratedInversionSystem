<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link href="css/bootstrap.min.css" rel="stylesheet">
    <title>IIS</title>
  </head>
  <body>
    <nav class="navbar">
      <div class="container">
        <div class="navbar-header">
          <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
            <span class="sr-only">Toggle navigation</span>
          </button>
          <a class="navbar-brand" onClick="showReadme()">Iterated Inversion System</a>
        </div>
        <div id="navbar" class="collapse navbar-collapse">
          <ul class="nav navbar-nav">
            <li class="active"><a onClick="showReadme()">Home</a></li>
          </ul>
        </div>
      </div>
    </nav>

    <div class="container">
      <div class="row">
	<div class="col-sm-5 col-md-3 sidebar-offcanvas">
	  <div class="well">
            <ul class="nav">
              <li><a onClick="reloadShader(this)"
                     id="kissing-Schottky" data-cw="512" data-ch="512">
                Kissing Schottky </a></li>
              <li><a onClick="reloadShader(this)"
                     id="kissing-Schottky-limit-set" data-cw="512" data-ch="512">
                Kissing Schottky Limit set </a></li>
              <li><a onClick="reloadShader(this)"
                     id="apollonian-packing" data-cw="512" data-ch="512">
                Apollonian packing </a></li>
              <li><a onClick="reloadShader(this)"
                     id="nine-circles" data-cw="512" data-ch="512">
                Group composed by 9 circles </a></li>
              <li><a onClick="reloadShader(this)"
                     id="3d-kissing-Schottky" data-cw="100" data-ch="100">
                3D kissing Schottky based on octahedron</a></li>
              <li><a onClick="reloadShader(this)"
                     id="3d-kissing-Schottky-limit-set" data-cw="100" data-ch="100">
                3D kissing Schottky based on octahedron Limit set</a></li>
              <li><a onClick="reloadShader(this)"
                     id="3d-kissing-Schottky2" data-cw="100" data-ch="100">
                3D kissing Schottky based on cube </a></li>
              <li><a onClick="reloadShader(this)"
                     id="3d-kissing-Schottky2-limit-set" data-cw="100" data-ch="100">
                3D kissing Schottky based on cube Limit set</a></li>
              <li><a onClick="reloadShader(this)"
                     id="indra" data-cw="100" data-ch="100">
                Indra's Bubbles</a></li>
            </ul>
	  </div>
        </div>
	<div class="col-sm-7 col-md-9">
          <div id="readme">
              <h1 id="iterated-inversion-system">Iterated Inversion System</h1>
            <p>Examples of the algorithm for drawing image of Schottky groups by WebGL and GLSL.
                  This is called Iterated Inversion System (IIS). It is easy to
                  parallelize and render images fast. It can be used to render
                  2-dimensional kissing Schottky groups and also 3-dimensional kissing
              Schottky groups.<br>3D examples may require high GPU power, so run these examples at your own risk.<br>Similar examples are also available on <a href="https://www.shadertoy.com/user/soma_arc">my Shadertoy page</a>. You can edit and run code easily. Some examples may run faster than running on my WebGL implementation.</p>
	    <h2 id="publication">Publication</h2>
	    <ul>
	      <li>
		Kento Nakamura and Kazushi Ahara, A New Algorithm for Rendering Kissing Schottky Groups, Bridges Finland 2016 Short Papers
		<ul>
		  <li><a href="http://archive.bridgesmathart.org/2016/bridges2016-367.html">Paper</a></li>
		  <li><a href="https://speakerdeck.com/soma_arc/a-new-algorithm-for-rendering-kissing-schottky-groups">Slide deck</a></li>
		</ul>
	      </li>
	    </ul>
	    <h2 id="relatedProject">Related Project</h2>
	    <ul>
	      <li>
		<a href="https://github.com/soma-arc/SchottkyLink">SchottkyLink</a><br>
		An interactive visualization system on a family of Kleinian groups based on Schottky groups
	      </li>
	    </ul>

            <h2 id="examples">Examples</h2>
            <h3 id="kissing-schottky">Kissing Schottky</h3>
            <p>This is basic kissing Schottky group composed by four circles.</p>
            <h4 id="orbit-of-the-schottky-circles">Orbit of the Schottky circles</h4>
            <p><img src="images/kissingSchottky.png" class="img-responsive"></p>
            <h4 id="limit-set">Limit set</h4>
            <p><img src="images/kissingSchottkyLimitSet.png" class="img-responsive"></p>
            <h3 id="apollonian-packing">Apollonian packing</h3>
            <p>This pattern is called apollonian packing. There are other algorithms for displaying it.
                  <img src="images/apollonianPacking.png" class="img-responsive"></p>
              <h3 id="group-composed-by-9-circles">Group composed by 9 circles</h3>
              <p>Actually, this is not Schottky group because Schottky groups are composed by even number of circles/spheres. However we can use this algorithm if groups are composed by circles/spheres.<br><img src="images/nineCircles.png" class="img-responsive"></p>
              <h3 id="3d-kissing-schottky-based-on-octahedron">3D kissing Schottky based on octahedron</h3>
              <p>This group is composed by 6 Schottky spheres at the position of the vertexes
                    of an octahedron.  </p>
              <h4 id="orbit-of-a-sphere">Orbit of a sphere</h4>
              <p><img src="images/3dOct.png" class="img-responsive"></p>
              <h4 id="limit-set">Limit set</h4>
              <p><img src="images/3dOctLimitSet.png" class="img-responsive" ></p>
              <h4 id="extra">Extra</h4>
              <p>Depending on the parameter, we can get such interesting image.
                    <img src="images/3dOctExt.png" class="img-responsive"></p>
                <h3 id="3d-kissing-schottky-based-on-cube">3D kissing Schottky based on cube</h3>
                <p>This group is composed by 8 Schottky spheres at the position of the vertexes
                      of a cube.  </p>
                <h4 id="orbit-of-a-sphere">Orbit of a sphere</h4>
                <p><img src="images/3dCube.png" class="img-responsive"></p>
                <h4 id="limit-set">Limit set</h4>
                <p><img src="images/3dCubeLimitSet.png" class="img-responsive"></p>
                <h3 id="indra-s-bubbles">Indra&#39;s Bubbles</h3>
                <p><a href="http://tokyodemofest.jp/2016/">Tokyo Demo Fest 2016</a> GLSL Graphics Compo 2nd Place.<br>This demo is using this algorithm.
                      <img src="images/indra.png" class="img-responsive"></p>
                  <h2 id="license">License</h2>
                  <h3 id="indra-s-bubbles">Indra&#39;s Bubbles</h3>
                  <p>Creative Commons Attribution-ShareAlike 3.0 Unported</p>
                  <h3 id="others">Others</h3>
                  <p>MIT</p>
          </div>
<div id="content">
    <h1 id="title"></h1>
  <button class="btn btn-default" onClick="enlargeCanvas()">enlarge</button>
  <button class="btn btn-default" onClick="reduceCanvas()">reduce</button>
  <br>
  <canvas id="canvas"></canvas>
</div>
	        </div>
      </div>
    </div>
    <script id="vertex" type="x-shader/x-vertex">
     attribute vec3 position;

     void main(void){
       gl_Position = vec4(position, 1.0);
     }
    </script>
    <script id="kissing-Schottky-frag" type="x-shader/x-fragment">
     precision mediump float;
     uniform float time;
     uniform vec2  mouse;
     uniform vec2  resolution;

     float LINE_THRESHOLD = 0.0001;
     vec3 getLine(vec2 p1, vec2 p2){
       float xDiff = p2.x - p1.x;
       float yDiff = p2.y - p1.y;
       if(abs(xDiff) < LINE_THRESHOLD){
         //x = c
         return vec3(1, 0, p1.x);
       }else if(abs(yDiff) < LINE_THRESHOLD){
         //y = c
         return vec3(0, 1, p1.y);
       }else{
         //y = ax + b
         return vec3(yDiff / xDiff, p1.y - p1.x * (yDiff / xDiff), 0);
       }
     }

     float calcX(vec3 line, float y){
       if(line.z == 0.){
         return (y - line.y) / line.x;
       }else{
         return line.z;
       }
     }

     float calcY(vec3 line, float x){
       if(line.z == 0.){
         return line.x * x + line.y;
       }else{
         return line.z;
       }
     }

     vec2 calcIntersection(vec3 line1, vec3 line2){
       if(line1.z == 0. && line2.z == 0.){
         float x1 = 1.;
         float x2 = 5.;
         float y1 = calcY(line1, x1);
         float y2 = calcY(line1, x2);

         float x3 = 4.;
         float x4 = 8.;
         float y3 = calcY(line2, x3);
         float y4 = calcY(line2, x4);

         float ksi   = ( y4-y3 )*( x4-x1 ) - ( x4-x3 )*( y4-y1 );
         float eta   = ( x2-x1 )*( y4-y1 ) - ( y2-y1 )*( x4-x1 );
         float delta = ( x2-x1 )*( y4-y3 ) - ( y2-y1 )*( x4-x3 );

         float lambda = ksi / delta;
         float mu    = eta / delta;
         return vec2(x1 + lambda*( x2-x1 ), y1 + lambda*( y2-y1 ));
       }else{
         if(line1.x == 1.){
           return vec2(line1.z, calcY(line2, line1.z));
         }else if(line1.y == 1.){
           return vec2(calcX(line2, line1.z), line1.z);
         }else if(line2.x == 1.){
           return vec2(line2.z, calcY(line1, line2.z));
         }
         return vec2(calcX(line1, line2.z), line2.z);
       }
     }

     const vec2 commonCirclePos = vec2(0, 0);
     const float commonCircleR = 100.;
     const vec2 p = commonCirclePos + vec2(0, commonCircleR);
     const vec2 q = commonCirclePos + vec2(-commonCircleR, 0);
     const vec2 r = commonCirclePos + vec2(0, -commonCircleR);
     const vec2 s = commonCirclePos + vec2(commonCircleR, 0);

     vec2 c1Pos, c2Pos, c3Pos, c4Pos;
     float c1R, c2R, c3R, c4R;

     void calcContactCircles(vec2 commonCirclePos, float commonCircleR){
       vec2 pqMid = (p + q)/2.;
       vec2 u = (pqMid - commonCirclePos)/distance(commonCirclePos, pqMid);
       vec2 a = u * commonCircleR * (sin(time) * 6. + 6.72) + commonCirclePos;
       c1Pos = a;
       c1R = distance(a, p);

       vec3 aq = getLine(a, q);
       vec3 qrMidPer = getLine(commonCirclePos, (q + r) / 2.);
       vec2 b = calcIntersection(aq, qrMidPer);
       c2Pos = b;
       c2R = distance(b, q);

       vec3 br = getLine(b, r);
       vec3 rsMidPer = getLine(commonCirclePos, (r + s) / 2.);
       vec2 c = calcIntersection(br, rsMidPer);
       c3Pos = c;
       c3R = distance(c, r);

       vec3 cs = getLine(c, s);
       vec3 spMidPer = getLine(commonCirclePos, (s + p) / 2.);
       vec2 d = calcIntersection(cs, spMidPer);
       c4Pos = d;
       c4R = distance(d, s);
     }

     vec2 circleInvert(vec2 pos, vec2 circlePos, float circleR){
       return ((pos - circlePos) * circleR * circleR)/(length(pos - circlePos) * length(pos - circlePos) ) + circlePos;
     }

     const int ITERATIONS = 30;
     float loopNum = 0.;
     float DE(vec2 pos){
       bool cont = false;
       for(int i = 0 ; i < ITERATIONS ; i++){
         cont = false;
         if(length(pos - c1Pos) < c1R){
           pos = circleInvert(pos, c1Pos, c1R);
           cont = true;
           loopNum++;
         }else if(length(pos - c2Pos) < c2R){
           pos = circleInvert(pos, c2Pos, c2R);
           cont = true;
           loopNum++;
         }else if(length(pos - c3Pos) < c3R){
           pos = circleInvert(pos, c3Pos, c3R);
           cont = true;
           loopNum++;
         }else if(length(pos - c4Pos) < c4R){
           pos = circleInvert(pos, c4Pos, c4R);
           cont = true;
           loopNum++;
         }
         if(cont == false) break;
       }

       return length(pos) - commonCircleR;
     }

     vec3 hsv2rgb(vec3 c){
       vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
       vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
       return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
     }

     void main(){
       float ratio = resolution.x / resolution.y / 2.0;
       vec2 position = ( gl_FragCoord.xy / resolution.yy ) - vec2(ratio, 0.5);
       position = position * 600.;

       calcContactCircles(commonCirclePos, commonCircleR);

       float d = DE(position);

       if(loopNum > 0.){
         vec3 hsv = vec3(0.04 * loopNum,1.0,1.0);
         gl_FragColor = vec4(hsv2rgb(hsv), 1.0);
       }else{
         gl_FragColor = vec4(0.,0.,0.,1.);
       }
     }
    </script>
    <script id="kissing-Schottky-limit-set-frag" type="x-shader/x-fragment">
     precision mediump float;
     uniform float time;
     uniform vec2  mouse;
     uniform vec2  resolution;

     float LINE_THRESHOLD = 0.0001;
     vec3 getLine(vec2 p1, vec2 p2){
       float xDiff = p2.x - p1.x;
       float yDiff = p2.y - p1.y;
       if(abs(xDiff) < LINE_THRESHOLD){
         //x = c
         return vec3(1, 0, p1.x);
       }else if(abs(yDiff) < LINE_THRESHOLD){
         //y = c
         return vec3(0, 1, p1.y);
       }else{
         //y = ax + b
         return vec3(yDiff / xDiff, p1.y - p1.x * (yDiff / xDiff), 0);
       }
     }

     float calcX(vec3 line, float y){
       if(line.z == 0.){
         return (y - line.y) / line.x;
       }else{
         return line.z;
       }
     }

     float calcY(vec3 line, float x){
       if(line.z == 0.){
         return line.x * x + line.y;
       }else{
         return line.z;
       }
     }

     vec2 calcIntersection(vec3 line1, vec3 line2){
       if(line1.z == 0. && line2.z == 0.){
         float x1 = 1.;
         float x2 = 5.;
         float y1 = calcY(line1, x1);
         float y2 = calcY(line1, x2);

         float x3 = 4.;
         float x4 = 8.;
         float y3 = calcY(line2, x3);
         float y4 = calcY(line2, x4);

         float ksi   = ( y4-y3 )*( x4-x1 ) - ( x4-x3 )*( y4-y1 );
         float eta   = ( x2-x1 )*( y4-y1 ) - ( y2-y1 )*( x4-x1 );
         float delta = ( x2-x1 )*( y4-y3 ) - ( y2-y1 )*( x4-x3 );

         float lambda = ksi / delta;
         float mu    = eta / delta;
         return vec2(x1 + lambda*( x2-x1 ), y1 + lambda*( y2-y1 ));
       }else{
         if(line1.x == 1.){
           return vec2(line1.z, calcY(line2, line1.z));
         }else if(line1.y == 1.){
           return vec2(calcX(line2, line1.z), line1.z);
         }else if(line2.x == 1.){
           return vec2(line2.z, calcY(line1, line2.z));
         }
         return vec2(calcX(line1, line2.z), line2.z);
       }
     }

     const vec2 commonCirclePos = vec2(0, 0);
     const float commonCircleR = 100.;
     const vec2 p = commonCirclePos + vec2(0, commonCircleR);
     const vec2 q = commonCirclePos + vec2(-commonCircleR, 0);
     const vec2 r = commonCirclePos + vec2(0, -commonCircleR);
     const vec2 s = commonCirclePos + vec2(commonCircleR, 0);

     vec2 c1Pos, c2Pos, c3Pos, c4Pos;
     float c1R, c2R, c3R, c4R;

     void calcContactCircles(vec2 commonCirclePos, float commonCircleR){
       vec2 pqMid = (p + q)/2.;
       vec2 u = (pqMid - commonCirclePos)/distance(commonCirclePos, pqMid);
       vec2 a = u * commonCircleR * (sin(time) * 6. + 6.72) + commonCirclePos;
       c1Pos = a;
       c1R = distance(a, p);

       vec3 aq = getLine(a, q);
       vec3 qrMidPer = getLine(commonCirclePos, (q + r) / 2.);
       vec2 b = calcIntersection(aq, qrMidPer);
       c2Pos = b;
       c2R = distance(b, q);

       vec3 br = getLine(b, r);
       vec3 rsMidPer = getLine(commonCirclePos, (r + s) / 2.);
       vec2 c = calcIntersection(br, rsMidPer);
       c3Pos = c;
       c3R = distance(c, r);

       vec3 cs = getLine(c, s);
       vec3 spMidPer = getLine(commonCirclePos, (s + p) / 2.);
       vec2 d = calcIntersection(cs, spMidPer);
       c4Pos = d;
       c4R = distance(d, s);
     }

     vec2 circleInvert(vec2 pos, vec2 circlePos, float circleR){
       return ((pos - circlePos) * circleR * circleR)/(length(pos - circlePos) * length(pos - circlePos) ) + circlePos;
     }

     const int ITERATIONS = 30;
     float loopNum = 0.;
     float DE(vec2 pos){
       bool cont = false;
       for(int i = 0 ; i < ITERATIONS ; i++){
         cont = false;
         if(length(pos - c1Pos) < c1R){
           pos = circleInvert(pos, c1Pos, c1R);
           cont = true;
           loopNum++;
         }else if(length(pos - c2Pos) < c2R){
           pos = circleInvert(pos, c2Pos, c2R);
           cont = true;
           loopNum++;
         }else if(length(pos - c3Pos) < c3R){
           pos = circleInvert(pos, c3Pos, c3R);
           cont = true;
           loopNum++;
         }else if(length(pos - c4Pos) < c4R){
           pos = circleInvert(pos, c4Pos, c4R);
           cont = true;
           loopNum++;
         }
         if(cont == false) break;
       }

       return length(pos) - commonCircleR;
     }

     vec3 hsv2rgb(vec3 c){
       vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
       vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
       return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
     }

     void main(){
       float ratio = resolution.x / resolution.y / 2.0;
       vec2 position = ( gl_FragCoord.xy / resolution.yy ) - vec2(ratio, 0.5);
       position = position * 600.;

       calcContactCircles(commonCirclePos, commonCircleR);

       float d = DE(position);

       if(d < 0.01){
         vec3 hsv = vec3(0.04 * loopNum,1.0,1.0);
         gl_FragColor = vec4(hsv2rgb(hsv), 1.0);
       }else{
         gl_FragColor = vec4(0.,0.,0.,1.);
       }
     }

    </script>
    <script id="apollonian-packing-frag" type="x-shader/x-fragment">
     precision mediump float;
     uniform float time;
     uniform vec2  mouse;
     uniform vec2  resolution;

     const vec2 c1Pos = vec2(0, 1);
     const vec2 c2Pos = vec2(4, 4);
     const vec2 c3Pos = vec2(-4, 4);
     const float c1R = 1.;
     const float c2R = 4.;
     const float c3R = 4.;

     vec2 circleInverse(vec2 pos, vec2 circlePos, float circleR){
       return ((pos - circlePos) * circleR * circleR)/(length(pos - circlePos) * length(pos - circlePos) ) + circlePos;
     }

     const int ITERATIONS = 50;
     float loopNum = 0.;
     float DE(vec2 pos){
       bool cont = false;
       for(int i = 0 ; i < ITERATIONS ; i++){
         cont = false;
         if(distance(pos,c1Pos) < c1R){
           pos = circleInverse(pos, c1Pos, c1R);
           cont = true;
           loopNum++;
         }else if(distance(pos, c2Pos) < c2R){
           pos = circleInverse(pos, c2Pos, c2R);
           cont = true;
           loopNum++;
         }else if(distance(pos, c3Pos) < c3R){
           pos = circleInverse(pos, c3Pos, c3R);
           cont = true;
           loopNum++;
         }else if(pos.y < 0.){
           pos = vec2(pos.x, -pos.y);
           cont = true;
           loopNum++;
         }
         if(cont == false) break;
       }

       return length(pos);
     }

     vec3 hsv2rgb(vec3 c)
     {
       vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
       vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
       return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
     }

     void main(){
       float ratio = resolution.x / resolution.y / 2.0;
       vec2 position = ( gl_FragCoord.xy / resolution.yy ) - vec2(ratio, 0.5);
       position = position *10.;

       float d = DE(position);

       if(loopNum != 0.){
         vec3 hsv = vec3(sin(time)+ 0.04 * loopNum,1.0,1.0);
         gl_FragColor = vec4(hsv2rgb(hsv), 1.0);
       }else{
         gl_FragColor = vec4(0.,0.,0.,1.);
       }
     }
    </script>
    <script id="nine-circles-frag" type="x-shader/x-fragment">
     precision mediump float;
     uniform float time;
     uniform vec2  mouse;
     uniform vec2  resolution;

     const vec2 c1Pos = vec2(1, 1);
     const vec2 c2Pos = vec2(-1, 1);
     const vec2 c3Pos = vec2(1, -1);
     const vec2 c4Pos = vec2(-1, -1);
     const vec2 c5Pos = vec2(0, 2.73205080757);//2 * sqrt(3) + 1;
     const vec2 c6Pos = vec2(0, -2.73205080757);
     const vec2 c7Pos = vec2(2.73205080757, 0.);
     const vec2 c8Pos = vec2(-2.73205080757, 0.);
     const vec2 c9Pos = vec2(0, 0);
     const float r = 1.;
     const float c9R = 0.4142;//2 * sqrt(2) - 2

     vec2 circleInvert(vec2 pos, vec2 circlePos, float circleR){
       return ((pos - circlePos) * circleR * circleR)/(length(pos - circlePos) * length(pos - circlePos) ) + circlePos;
     }

     const int ITERATIONS = 50;
     float loopNum = 0.;
     float DE(vec2 pos){
       bool cont = false;
       for(int i = 0 ; i < ITERATIONS ; i++){
         cont = false;
         if(distance(pos,c1Pos) < r){
           pos = circleInvert(pos, c1Pos, r);
           cont = true;
           loopNum++;
         }else if(distance(pos, c2Pos) < r){
           pos = circleInvert(pos, c2Pos, r);
           cont = true;
           loopNum++;
         }else if(distance(pos, c3Pos) < r){
           pos = circleInvert(pos, c3Pos, r);
           cont = true;
           loopNum++;
         }else if(distance(pos, c4Pos) < r){
           pos = circleInvert(pos, c4Pos, r);
           cont = true;
           loopNum++;
         }else if(distance(pos, c5Pos) < r){
           pos = circleInvert(pos, c5Pos, r);
           cont = true;
           loopNum++;
         }else if(distance(pos, c6Pos) < r){
           pos = circleInvert(pos, c6Pos, r);
           cont = true;
           loopNum++;
         }else if(distance(pos, c7Pos) < r){
           pos = circleInvert(pos, c7Pos, r);
           cont = true;
           loopNum++;
         }else if(distance(pos, c8Pos) < r){
           pos = circleInvert(pos, c8Pos, r);
           cont = true;
           loopNum++;
         }else if(distance(pos, c9Pos) < c9R){
           pos = circleInvert(pos, c9Pos, c9R);
           cont = true;
           loopNum++;
         }
         if(cont == false) break;
       }

       return length(pos);
     }

     vec3 hsv2rgb(vec3 c)
     {
       vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
       vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
       return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
     }

     void main(){
       float ratio = resolution.x / resolution.y / 2.0;
       vec2 position = ( gl_FragCoord.xy / resolution.yy ) - vec2(ratio, 0.5);
       position = position * 5.;

       float d = DE(position);

       if(loopNum != 0.){
         vec3 hsv = vec3(sin(time)+ 0.04 * loopNum,1.0,1.0);
         gl_FragColor = vec4(hsv2rgb(hsv), 1.0);
       }else{
         gl_FragColor = vec4(0.,0.,0.,1.);
       }
     }
    </script>
    <script id="3d-kissing-Schottky-frag" type="x-shader/x-fragment">
     precision mediump float;
     uniform float time;
     uniform vec2  mouse;
     uniform vec2  resolution;

     vec3 ROTATION_AXIS = normalize(vec3(0.1, 1, 0.5));
     vec3 rotate(vec3 p, float angle){
       float s = sin(angle);
       float c = cos(angle);
       float r = 1.0 - c;
       mat3 m = mat3(ROTATION_AXIS.x * ROTATION_AXIS.x * r + c,
                     ROTATION_AXIS.y * ROTATION_AXIS.x * r + ROTATION_AXIS.z * s,
                     ROTATION_AXIS.z * ROTATION_AXIS.x * r - ROTATION_AXIS.y * s,
                     ROTATION_AXIS.x * ROTATION_AXIS.y * r - ROTATION_AXIS.z * s,
                     ROTATION_AXIS.y * ROTATION_AXIS.y * r + c,
                     ROTATION_AXIS.z * ROTATION_AXIS.y * r + ROTATION_AXIS.x * s,
                     ROTATION_AXIS.x * ROTATION_AXIS.z * r + ROTATION_AXIS.y * s,
                     ROTATION_AXIS.y * ROTATION_AXIS.z * r - ROTATION_AXIS.x * s,
                     ROTATION_AXIS.z * ROTATION_AXIS.z * r + c);
       return m * p;
     }

     const vec3 SPHERE_POS1 = vec3(300, 300, 0);
     const vec3 SPHERE_POS2 = vec3(300, -300, 0);
     const vec3 SPHERE_POS3 = vec3(-300, 300, 0);
     const vec3 SPHERE_POS4 = vec3(-300, -300, 0);
     const vec3 SPHERE_POS5 = vec3(0, 0, 424.26);
     const vec3 SPHERE_POS6 = vec3(0, 0, -424.26);
     const float SPHERE_R = 300.;
     const float SPHERE_R2 = SPHERE_R * SPHERE_R;

     vec3 sphereInvert(vec3 pos, vec3 circlePos, float circleR){
       return ((pos - circlePos) * circleR * circleR)/(distance(pos, circlePos) * distance(pos, circlePos) ) + circlePos;
     }

     float loopNum = 0.;
     float kleinSphereR = 125.;
     const int MAX_KLEIN_ITARATION = 30;
     float distKlein(vec3 pos){
       pos = rotate(pos, radians(time * 30.));
       loopNum = 0.;
       float dr = 1.;
       bool loopEnd = true;
       for(int i = 0 ; i < MAX_KLEIN_ITARATION ; i++){
         loopEnd = true;
         if(distance(pos, SPHERE_POS1) < SPHERE_R){
           vec3 diff = (pos - SPHERE_POS1);
           dr *= SPHERE_R2 / dot(diff, diff);
           pos = sphereInvert(pos, SPHERE_POS1, SPHERE_R);
           loopEnd = false;
           loopNum++;
         }else if(distance(pos, SPHERE_POS2) < SPHERE_R){
           vec3 diff = (pos- SPHERE_POS2);
           dr *= SPHERE_R2 / dot(diff, diff);
           pos = sphereInvert(pos, SPHERE_POS2, SPHERE_R);
           loopEnd = false;
           loopNum++;
         }else if(distance(pos, SPHERE_POS3) < SPHERE_R){
           vec3 diff = (pos- SPHERE_POS3);
           dr *= SPHERE_R2 / dot(diff, diff);
           pos = sphereInvert(pos, SPHERE_POS3, SPHERE_R);
           loopEnd = false;
           loopNum++;
         }else if(distance(pos, SPHERE_POS4) < SPHERE_R){
           vec3 diff = (pos- SPHERE_POS4);
           dr *= SPHERE_R2 / dot(diff, diff);
           pos = sphereInvert(pos, SPHERE_POS4, SPHERE_R);
           loopEnd = false;
           loopNum++;
         }else if(distance(pos, SPHERE_POS5) < SPHERE_R){
           vec3 diff = (pos- SPHERE_POS5);
           dr *= SPHERE_R2 / dot(diff, diff);
           pos = sphereInvert(pos, SPHERE_POS5, SPHERE_R);
           loopEnd = false;
           loopNum++;
         }else if(distance(pos, SPHERE_POS6) < SPHERE_R){
           vec3 diff = (pos- SPHERE_POS6);
           dr *= SPHERE_R2 / dot(diff, diff);
           pos = sphereInvert(pos, SPHERE_POS6, SPHERE_R);
           loopEnd = false;
           loopNum++;
         }
         if(loopEnd == true) break;
       }
       return (length(pos) - kleinSphereR) / abs(dr) * 0.08;
     }

     vec3 calcRay (const vec3 eye, const vec3 target, const vec3 up, const float fov,
                   const float width, const float height, const vec2 coord){
                     float imagePlane = (height * .5) / tan(fov * .5);
                     vec3 v = normalize(target - eye);
                     vec3 xaxis = normalize(cross(v, up));
                     vec3 yaxis =  normalize(cross(v, xaxis));
                     vec3 center = v * imagePlane;
                     vec3 origin = center - (xaxis * (width  *.5)) - (yaxis * (height * .5));
                     return normalize(origin + (xaxis * coord.x) + (yaxis * (height - coord.y)));
                   }

     const vec4 K = vec4(1.0, .666666, .333333, 3.0);
     vec3 hsv2rgb(const vec3 c){
       vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
       return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
     }

     float distFunc(vec3 p){
       return distKlein(p);
     }

     const vec2 d = vec2(0.01, 0.);
     vec3 getNormal(const vec3 p){
       return normalize(vec3(distFunc(p + d.xyy) - distFunc(p - d.xyy),
                             distFunc(p + d.yxy) - distFunc(p - d.yxy),
                             distFunc(p + d.yyx) - distFunc(p - d.yyx)));
     }

     const float PI_4 = 12.566368;
     const vec3 LIGHTING_FACT = vec3(0.1);
     vec3 diffuseLighting(const vec3 p, const vec3 n, const vec3 diffuseColor,
                          const vec3 lightPos, const vec3 lightPower){
                            vec3 v = lightPos - p;
                            float dot = dot(n, normalize(v));
                            float r = length(v);
                            return (dot > 0.) ?
                                             (lightPower * (dot / (PI_4 * r * r))) * diffuseColor
                                                                  : LIGHTING_FACT * diffuseColor;
                          }

     const vec3 lightPos = vec3(400, 0, 500);
     const vec3 lightPos2 = vec3(-300., -300., -300);
     const vec3 lightPower = vec3(800000.);
     const vec3 lightPoweSPHERE_R2 = vec3(10000.);

     const int MAX_MARCHING_LOOP = 800;
     vec2 march(const vec3 origin, const  vec3 ray, const float threshold){
       vec3 rayPos = origin;
       float dist;
       float rayLength = 0.;
       for(int i = 0 ; i < MAX_MARCHING_LOOP ; i++){
         dist = distFunc(rayPos);
         rayLength += dist;
         rayPos = origin + ray * rayLength ;
         if(dist < threshold) break;
       }
       return vec2(dist, rayLength);
     }

     const vec3 BLACK = vec3(0);
     vec3 calcColor(vec3 eye, vec3 ray){
       vec3 l = BLACK;
       float coeff = 1.;
       vec2 result = march(eye, ray, 0.01);
       vec3 intersection = eye + ray * result.y;
       vec3 matColor = vec3(0);
       vec3 normal = getNormal(intersection);
       if(result.x < 0.01){
         matColor = hsv2rgb(vec3(0.1 + loopNum * 0.1 , 1., 1.));
         l += diffuseLighting(intersection, normal, matColor, lightPos, lightPower);
         l += diffuseLighting(intersection, normal, matColor, lightPos2, lightPower);
       }
       return l;
     }

     const float DISPLAY_GAMMA_COEFF = 1. / 2.2;
     vec3 gammaCorrect(vec3 rgb) {
       return vec3((min(pow(rgb.r, DISPLAY_GAMMA_COEFF), 1.)),
                   (min(pow(rgb.g, DISPLAY_GAMMA_COEFF), 1.)),
                   (min(pow(rgb.b, DISPLAY_GAMMA_COEFF), 1.)));
     }

     const vec3 eye = vec3(300 , 0., 550 );
     const vec3 target = vec3(0, 0, 0);
     const vec3 up = vec3(0, 1, 0);
     float fov = radians(60.);
     void main(){
       const vec2 coordOffset = vec2(0.5);
       vec3 ray = calcRay(eye, target, up, fov,
                          resolution.x, resolution.y,
                          gl_FragCoord.xy + coordOffset);

       gl_FragColor = vec4(gammaCorrect(calcColor(eye, ray)), 1.);
     }

    </script>
    <script id="3d-kissing-Schottky-limit-set-frag" type="x-shader/x-fragment">
     precision mediump float;
     uniform float time;
     uniform vec2  mouse;
     uniform vec2  resolution;

     vec3 ROTATION_AXIS = normalize(vec3(0.1, 1, 0.5));
     vec3 rotate(vec3 p, float angle){
       float s = sin(angle);
       float c = cos(angle);
       float r = 1.0 - c;
       mat3 m = mat3(ROTATION_AXIS.x * ROTATION_AXIS.x * r + c,
                     ROTATION_AXIS.y * ROTATION_AXIS.x * r + ROTATION_AXIS.z * s,
                     ROTATION_AXIS.z * ROTATION_AXIS.x * r - ROTATION_AXIS.y * s,
                     ROTATION_AXIS.x * ROTATION_AXIS.y * r - ROTATION_AXIS.z * s,
                     ROTATION_AXIS.y * ROTATION_AXIS.y * r + c,
                     ROTATION_AXIS.z * ROTATION_AXIS.y * r + ROTATION_AXIS.x * s,
                     ROTATION_AXIS.x * ROTATION_AXIS.z * r + ROTATION_AXIS.y * s,
                     ROTATION_AXIS.y * ROTATION_AXIS.z * r - ROTATION_AXIS.x * s,
                     ROTATION_AXIS.z * ROTATION_AXIS.z * r + c);
       return m * p;
     }

     const vec3 SPHERE_POS1 = vec3(300, 300, 0);
     const vec3 SPHERE_POS2 = vec3(300, -300, 0);
     const vec3 SPHERE_POS3 = vec3(-300, 300, 0);
     const vec3 SPHERE_POS4 = vec3(-300, -300, 0);
     const vec3 SPHERE_POS5 = vec3(0, 0, 424.26);
     const vec3 SPHERE_POS6 = vec3(0, 0, -424.26);
     const float SPHERE_R = 300.;
     const float SPHERE_R2 = SPHERE_R * SPHERE_R;

     vec3 sphereInvert(vec3 pos, vec3 circlePos, float circleR){
       return ((pos - circlePos) * circleR * circleR)/(distance(pos, circlePos) * distance(pos, circlePos) ) + circlePos;
     }

     float loopNum = 0.;
     float kleinSphereR = 300.;
     const int MAX_KLEIN_ITARATION = 30;
     float distKlein(vec3 pos){
       pos = rotate(pos, radians(time * 30.));
       loopNum = 0.;
       float dr = 1.;
       bool loopEnd = true;
       for(int i = 0 ; i < MAX_KLEIN_ITARATION ; i++){
         loopEnd = true;
         if(distance(pos, SPHERE_POS1) < SPHERE_R){
           vec3 diff = (pos - SPHERE_POS1);
           dr *= SPHERE_R2 / dot(diff, diff);
           pos = sphereInvert(pos, SPHERE_POS1, SPHERE_R);
           loopEnd = false;
           loopNum++;
         }else if(distance(pos, SPHERE_POS2) < SPHERE_R){
           vec3 diff = (pos- SPHERE_POS2);
           dr *= SPHERE_R2 / dot(diff, diff);
           pos = sphereInvert(pos, SPHERE_POS2, SPHERE_R);
           loopEnd = false;
           loopNum++;
         }else if(distance(pos, SPHERE_POS3) < SPHERE_R){
           vec3 diff = (pos- SPHERE_POS3);
           dr *= SPHERE_R2 / dot(diff, diff);
           pos = sphereInvert(pos, SPHERE_POS3, SPHERE_R);
           loopEnd = false;
           loopNum++;
         }else if(distance(pos, SPHERE_POS4) < SPHERE_R){
           vec3 diff = (pos- SPHERE_POS4);
           dr *= SPHERE_R2 / dot(diff, diff);
           pos = sphereInvert(pos, SPHERE_POS4, SPHERE_R);
           loopEnd = false;
           loopNum++;
         }else if(distance(pos, SPHERE_POS5) < SPHERE_R){
           vec3 diff = (pos- SPHERE_POS5);
           dr *= SPHERE_R2 / dot(diff, diff);
           pos = sphereInvert(pos, SPHERE_POS5, SPHERE_R);
           loopEnd = false;
           loopNum++;
         }else if(distance(pos, SPHERE_POS6) < SPHERE_R){
           vec3 diff = (pos- SPHERE_POS6);
           dr *= SPHERE_R2 / dot(diff, diff);
           pos = sphereInvert(pos, SPHERE_POS6, SPHERE_R);
           loopEnd = false;
           loopNum++;
         }
         if(loopEnd == true) break;
       }
       return (length(pos) - kleinSphereR) / abs(dr) * 0.08;
     }

     vec3 calcRay (const vec3 eye, const vec3 target, const vec3 up, const float fov,
                   const float width, const float height, const vec2 coord){
                     float imagePlane = (height * .5) / tan(fov * .5);
                     vec3 v = normalize(target - eye);
                     vec3 xaxis = normalize(cross(v, up));
                     vec3 yaxis =  normalize(cross(v, xaxis));
                     vec3 center = v * imagePlane;
                     vec3 origin = center - (xaxis * (width  *.5)) - (yaxis * (height * .5));
                     return normalize(origin + (xaxis * coord.x) + (yaxis * (height - coord.y)));
                   }

     const vec4 K = vec4(1.0, .666666, .333333, 3.0);
     vec3 hsv2rgb(const vec3 c){
       vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
       return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
     }

     float distFunc(vec3 p){
       return distKlein(p);
     }

     const vec2 d = vec2(0.01, 0.);
     vec3 getNormal(const vec3 p){
       return normalize(vec3(distFunc(p + d.xyy) - distFunc(p - d.xyy),
                             distFunc(p + d.yxy) - distFunc(p - d.yxy),
                             distFunc(p + d.yyx) - distFunc(p - d.yyx)));
     }

     const float PI_4 = 12.566368;
     const vec3 LIGHTING_FACT = vec3(0.1);
     vec3 diffuseLighting(const vec3 p, const vec3 n, const vec3 diffuseColor,
                          const vec3 lightPos, const vec3 lightPower){
                            vec3 v = lightPos - p;
                            float dot = dot(n, normalize(v));
                            float r = length(v);
                            return (dot > 0.) ?
                                             (lightPower * (dot / (PI_4 * r * r))) * diffuseColor
                                                                  : LIGHTING_FACT * diffuseColor;
                          }

     const vec3 lightPos = vec3(400, 0, 500);
     const vec3 lightPos2 = vec3(-300., -300., -300);
     const vec3 lightPower = vec3(800000.);
     const vec3 lightPoweSPHERE_R2 = vec3(10000.);

     const int MAX_MARCHING_LOOP = 800;
     vec2 march(const vec3 origin, const  vec3 ray, const float threshold){
       vec3 rayPos = origin;
       float dist;
       float rayLength = 0.;
       for(int i = 0 ; i < MAX_MARCHING_LOOP ; i++){
         dist = distFunc(rayPos);
         rayLength += dist;
         rayPos = origin + ray * rayLength ;
         if(dist < threshold) break;
       }
       return vec2(dist, rayLength);
     }

     const vec3 BLACK = vec3(0);
     vec3 calcColor(vec3 eye, vec3 ray){
       vec3 l = BLACK;
       float coeff = 1.;
       vec2 result = march(eye, ray, 0.01);
       vec3 intersection = eye + ray * result.y;
       vec3 matColor = vec3(0);
       vec3 normal = getNormal(intersection);
       if(result.x < 0.01){
         matColor = hsv2rgb(vec3(0.1 + loopNum * 0.1 , 1., 1.));
         l += diffuseLighting(intersection, normal, matColor, lightPos, lightPower);
         l += diffuseLighting(intersection, normal, matColor, lightPos2, lightPower);
       }
       return l;
     }

     const float DISPLAY_GAMMA_COEFF = 1. / 2.2;
     vec3 gammaCorrect(vec3 rgb) {
       return vec3((min(pow(rgb.r, DISPLAY_GAMMA_COEFF), 1.)),
                   (min(pow(rgb.g, DISPLAY_GAMMA_COEFF), 1.)),
                   (min(pow(rgb.b, DISPLAY_GAMMA_COEFF), 1.)));
     }

     const vec3 eye = vec3(300 , 0., 550 );
     const vec3 target = vec3(0, 0, 0);
     const vec3 up = vec3(0, 1, 0);
     float fov = radians(60.);
     void main(){
       const vec2 coordOffset = vec2(0.5);
       vec3 ray = calcRay(eye, target, up, fov,
                          resolution.x, resolution.y,
                          gl_FragCoord.xy + coordOffset);

       gl_FragColor = vec4(gammaCorrect(calcColor(eye, ray)), 1.);
     }

    </script>
    <script id="3d-kissing-Schottky2-frag" type="x-shader/x-fragment">
     precision mediump float;
     uniform float time;
     uniform vec2  mouse;
     uniform vec2  resolution;

     vec3 ROTATION_AXIS = normalize(vec3(0.1, 1, 0.5));
     vec3 rotate(vec3 p, float angle){
       float s = sin(angle);
       float c = cos(angle);
       float r = 1.0 - c;
       mat3 m = mat3(ROTATION_AXIS.x * ROTATION_AXIS.x * r + c,
                     ROTATION_AXIS.y * ROTATION_AXIS.x * r + ROTATION_AXIS.z * s,
                     ROTATION_AXIS.z * ROTATION_AXIS.x * r - ROTATION_AXIS.y * s,
                     ROTATION_AXIS.x * ROTATION_AXIS.y * r - ROTATION_AXIS.z * s,
                     ROTATION_AXIS.y * ROTATION_AXIS.y * r + c,
                     ROTATION_AXIS.z * ROTATION_AXIS.y * r + ROTATION_AXIS.x * s,
                     ROTATION_AXIS.x * ROTATION_AXIS.z * r + ROTATION_AXIS.y * s,
                     ROTATION_AXIS.y * ROTATION_AXIS.z * r - ROTATION_AXIS.x * s,
                     ROTATION_AXIS.z * ROTATION_AXIS.z * r + c);
       return m * p;
     }

     const vec3 SPHERE_POS1 = vec3(300, 300, 300);
     const vec3 SPHERE_POS2 = vec3(300, -300, 300);
     const vec3 SPHERE_POS3 = vec3(-300, 300, 300);
     const vec3 SPHERE_POS4 = vec3(-300, -300, 300);
     const vec3 SPHERE_POS5 = vec3(300, 300, -300);
     const vec3 SPHERE_POS6 = vec3(300, -300,-300);
     const vec3 SPHERE_POS7 = vec3(-300, 300, -300);
     const vec3 SPHERE_POS8 = vec3(-300, -300, -300);
     const float SPHERE_R = 300.;
     const float SPHERE_R2 = SPHERE_R * SPHERE_R;

     vec3 sphereInvert(vec3 pos, vec3 circlePos, float circleR){
       return ((pos - circlePos) * circleR * circleR)/(distance(pos, circlePos) * distance(pos, circlePos) ) + circlePos;
     }

     float loopNum = 0.;
     float kleinSphereR = 219.62;
     const int MAX_KLEIN_ITARATION = 10;
     float distKlein(vec3 pos){
       pos = rotate(pos, radians(time * 30.));
       loopNum = 0.;
       float dr = 1.;
       bool loopEnd = true;
       for(int i = 0 ; i < MAX_KLEIN_ITARATION ; i++){
         loopEnd = true;
         if(distance(pos, SPHERE_POS1) < SPHERE_R){
           vec3 diff = (pos - SPHERE_POS1);
           dr *= SPHERE_R2 / dot(diff, diff);
           pos = sphereInvert(pos, SPHERE_POS1, SPHERE_R);
           loopEnd = false;
           loopNum++;
         }else if(distance(pos, SPHERE_POS2) < SPHERE_R){
           vec3 diff = (pos- SPHERE_POS2);
           dr *= SPHERE_R2 / dot(diff, diff);
           pos = sphereInvert(pos, SPHERE_POS2, SPHERE_R);
           loopEnd = false;
           loopNum++;
         }else if(distance(pos, SPHERE_POS3) < SPHERE_R){
           vec3 diff = (pos- SPHERE_POS3);
           dr *= SPHERE_R2 / dot(diff, diff);
           pos = sphereInvert(pos, SPHERE_POS3, SPHERE_R);
           loopEnd = false;
           loopNum++;
         }else if(distance(pos, SPHERE_POS4) < SPHERE_R){
           vec3 diff = (pos- SPHERE_POS4);
           dr *= SPHERE_R2 / dot(diff, diff);
           pos = sphereInvert(pos, SPHERE_POS4, SPHERE_R);
           loopEnd = false;
           loopNum++;
         }else if(distance(pos, SPHERE_POS5) < SPHERE_R){
           vec3 diff = (pos- SPHERE_POS5);
           dr *= SPHERE_R2 / dot(diff, diff);
           pos = sphereInvert(pos, SPHERE_POS5, SPHERE_R);
           loopEnd = false;
           loopNum++;
         }else if(distance(pos, SPHERE_POS6) < SPHERE_R){
           vec3 diff = (pos- SPHERE_POS6);
           dr *= SPHERE_R2 / dot(diff, diff);
           pos = sphereInvert(pos, SPHERE_POS6, SPHERE_R);
           loopEnd = false;
           loopNum++;
         }else if(distance(pos, SPHERE_POS7) < SPHERE_R){
           vec3 diff = (pos- SPHERE_POS7);
           dr *= SPHERE_R2 / dot(diff, diff);
           pos = sphereInvert(pos, SPHERE_POS7, SPHERE_R);
           loopEnd = false;
           loopNum++;
         }else if(distance(pos, SPHERE_POS8) < SPHERE_R){
           vec3 diff = (pos- SPHERE_POS8);
           dr *= SPHERE_R2 / dot(diff, diff);
           pos = sphereInvert(pos, SPHERE_POS8, SPHERE_R);
           loopEnd = false;
           loopNum++;
         }
         if(loopEnd == true) break;
       }
       return (length(pos) - kleinSphereR) / abs(dr) * 0.08;
     }

     vec3 calcRay (const vec3 eye, const vec3 target, const vec3 up, const float fov,
                   const float width, const float height, const vec2 coord){
                     float imagePlane = (height * .5) / tan(fov * .5);
                     vec3 v = normalize(target - eye);
                     vec3 xaxis = normalize(cross(v, up));
                     vec3 yaxis =  normalize(cross(v, xaxis));
                     vec3 center = v * imagePlane;
                     vec3 origin = center - (xaxis * (width  *.5)) - (yaxis * (height * .5));
                     return normalize(origin + (xaxis * coord.x) + (yaxis * (height - coord.y)));
                   }

     const vec4 K = vec4(1.0, .666666, .333333, 3.0);
     vec3 hsv2rgb(const vec3 c){
       vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
       return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
     }

     float distFunc(vec3 p){
       return distKlein(p);
     }

     const vec2 d = vec2(0.01, 0.);
     vec3 getNormal(const vec3 p){
       return normalize(vec3(distFunc(p + d.xyy) - distFunc(p - d.xyy),
                             distFunc(p + d.yxy) - distFunc(p - d.yxy),
                             distFunc(p + d.yyx) - distFunc(p - d.yyx)));
     }

     const float PI_4 = 12.566368;
     const vec3 LIGHTING_FACT = vec3(0.1);
     vec3 diffuseLighting(const vec3 p, const vec3 n, const vec3 diffuseColor,
                          const vec3 lightPos, const vec3 lightPower){
                            vec3 v = lightPos - p;
                            float dot = dot(n, normalize(v));
                            float r = length(v);
                            return (dot > 0.) ?
                                             (lightPower * (dot / (PI_4 * r * r))) * diffuseColor
                                                                  : LIGHTING_FACT * diffuseColor;
                          }

     const vec3 lightPos = vec3(400, 0, 500);
     const vec3 lightPos2 = vec3(-300., -300., -300);
     const vec3 lightPower = vec3(800000.);
     const vec3 lightPoweSPHERE_R2 = vec3(10000.);

     const int MAX_MARCHING_LOOP = 800;
     vec2 march(const vec3 origin, const  vec3 ray, const float threshold){
       vec3 rayPos = origin;
       float dist;
       float rayLength = 0.;
       for(int i = 0 ; i < MAX_MARCHING_LOOP ; i++){
         dist = distFunc(rayPos);
         rayLength += dist;
         rayPos = origin + ray * rayLength ;
         if(dist < threshold) break;
       }
       return vec2(dist, rayLength);
     }

     const vec3 BLACK = vec3(0);
     vec3 calcColor(vec3 eye, vec3 ray){
       vec3 l = BLACK;
       float coeff = 1.;
       vec2 result = march(eye, ray, 0.01);
       vec3 intersection = eye + ray * result.y;
       vec3 matColor = vec3(0);
       vec3 normal = getNormal(intersection);
       if(result.x < 0.01){
         matColor = hsv2rgb(vec3(0.1 + loopNum * 0.1 , 1., 1.));
         l += diffuseLighting(intersection, normal, matColor, lightPos, lightPower);
         l += diffuseLighting(intersection, normal, matColor, lightPos2, lightPower);
       }
       return l;
     }

     const float DISPLAY_GAMMA_COEFF = 1. / 2.2;
     vec3 gammaCorrect(vec3 rgb) {
       return vec3((min(pow(rgb.r, DISPLAY_GAMMA_COEFF), 1.)),
                   (min(pow(rgb.g, DISPLAY_GAMMA_COEFF), 1.)),
                   (min(pow(rgb.b, DISPLAY_GAMMA_COEFF), 1.)));
     }

     const vec3 eye = vec3(300 , 0., 850 );
     const vec3 target = vec3(0, 0, 0);
     const vec3 up = vec3(0, 1, 0);
     float fov = radians(60.);
     void main(){
       const vec2 coordOffset = vec2(0.5);
       vec3 ray = calcRay(eye, target, up, fov,
                          resolution.x, resolution.y,
                          gl_FragCoord.xy + coordOffset);

       gl_FragColor = vec4(gammaCorrect(calcColor(eye, ray)), 1.);
     }

    </script>
    <script id="3d-kissing-Schottky2-limit-set-frag" type="x-shader/x-fragment">
     precision mediump float;
     uniform float time;
     uniform vec2  mouse;
     uniform vec2  resolution;

     vec3 ROTATION_AXIS = normalize(vec3(0.1, 1, 0.5));
     vec3 rotate(vec3 p, float angle){
       float s = sin(angle);
       float c = cos(angle);
       float r = 1.0 - c;
       mat3 m = mat3(ROTATION_AXIS.x * ROTATION_AXIS.x * r + c,
                     ROTATION_AXIS.y * ROTATION_AXIS.x * r + ROTATION_AXIS.z * s,
                     ROTATION_AXIS.z * ROTATION_AXIS.x * r - ROTATION_AXIS.y * s,
                     ROTATION_AXIS.x * ROTATION_AXIS.y * r - ROTATION_AXIS.z * s,
                     ROTATION_AXIS.y * ROTATION_AXIS.y * r + c,
                     ROTATION_AXIS.z * ROTATION_AXIS.y * r + ROTATION_AXIS.x * s,
                     ROTATION_AXIS.x * ROTATION_AXIS.z * r + ROTATION_AXIS.y * s,
                     ROTATION_AXIS.y * ROTATION_AXIS.z * r - ROTATION_AXIS.x * s,
                     ROTATION_AXIS.z * ROTATION_AXIS.z * r + c);
       return m * p;
     }

     const vec3 SPHERE_POS1 = vec3(300, 300, 300);
     const vec3 SPHERE_POS2 = vec3(300, -300, 300);
     const vec3 SPHERE_POS3 = vec3(-300, 300, 300);
     const vec3 SPHERE_POS4 = vec3(-300, -300, 300);
     const vec3 SPHERE_POS5 = vec3(300, 300, -300);
     const vec3 SPHERE_POS6 = vec3(300, -300,-300);
     const vec3 SPHERE_POS7 = vec3(-300, 300, -300);
     const vec3 SPHERE_POS8 = vec3(-300, -300, -300);
     const float SPHERE_R = 300.;
     const float SPHERE_R2 = SPHERE_R * SPHERE_R;

     vec3 sphereInvert(vec3 pos, vec3 circlePos, float circleR){
       return ((pos - circlePos) * circleR * circleR)/(distance(pos, circlePos) * distance(pos, circlePos) ) + circlePos;
     }

     float loopNum = 0.;
     float kleinSphereR = 424.26;
     const int MAX_KLEIN_ITARATION = 10;
     float distKlein(vec3 pos){
       pos = rotate(pos, radians(time * 30.));
       loopNum = 0.;
       float dr = 1.;
       bool loopEnd = true;
       for(int i = 0 ; i < MAX_KLEIN_ITARATION ; i++){
         loopEnd = true;
         if(distance(pos, SPHERE_POS1) < SPHERE_R){
           vec3 diff = (pos - SPHERE_POS1);
           dr *= SPHERE_R2 / dot(diff, diff);
           pos = sphereInvert(pos, SPHERE_POS1, SPHERE_R);
           loopEnd = false;
           loopNum++;
         }else if(distance(pos, SPHERE_POS2) < SPHERE_R){
           vec3 diff = (pos- SPHERE_POS2);
           dr *= SPHERE_R2 / dot(diff, diff);
           pos = sphereInvert(pos, SPHERE_POS2, SPHERE_R);
           loopEnd = false;
           loopNum++;
         }else if(distance(pos, SPHERE_POS3) < SPHERE_R){
           vec3 diff = (pos- SPHERE_POS3);
           dr *= SPHERE_R2 / dot(diff, diff);
           pos = sphereInvert(pos, SPHERE_POS3, SPHERE_R);
           loopEnd = false;
           loopNum++;
         }else if(distance(pos, SPHERE_POS4) < SPHERE_R){
           vec3 diff = (pos- SPHERE_POS4);
           dr *= SPHERE_R2 / dot(diff, diff);
           pos = sphereInvert(pos, SPHERE_POS4, SPHERE_R);
           loopEnd = false;
           loopNum++;
         }else if(distance(pos, SPHERE_POS5) < SPHERE_R){
           vec3 diff = (pos- SPHERE_POS5);
           dr *= SPHERE_R2 / dot(diff, diff);
           pos = sphereInvert(pos, SPHERE_POS5, SPHERE_R);
           loopEnd = false;
           loopNum++;
         }else if(distance(pos, SPHERE_POS6) < SPHERE_R){
           vec3 diff = (pos- SPHERE_POS6);
           dr *= SPHERE_R2 / dot(diff, diff);
           pos = sphereInvert(pos, SPHERE_POS6, SPHERE_R);
           loopEnd = false;
           loopNum++;
         }else if(distance(pos, SPHERE_POS7) < SPHERE_R){
           vec3 diff = (pos- SPHERE_POS7);
           dr *= SPHERE_R2 / dot(diff, diff);
           pos = sphereInvert(pos, SPHERE_POS7, SPHERE_R);
           loopEnd = false;
           loopNum++;
         }else if(distance(pos, SPHERE_POS8) < SPHERE_R){
           vec3 diff = (pos- SPHERE_POS8);
           dr *= SPHERE_R2 / dot(diff, diff);
           pos = sphereInvert(pos, SPHERE_POS8, SPHERE_R);
           loopEnd = false;
           loopNum++;
         }
         if(loopEnd == true) break;
       }
       return (length(pos) - kleinSphereR) / abs(dr) * 0.08;
     }

     vec3 calcRay (const vec3 eye, const vec3 target, const vec3 up, const float fov,
                   const float width, const float height, const vec2 coord){
                     float imagePlane = (height * .5) / tan(fov * .5);
                     vec3 v = normalize(target - eye);
                     vec3 xaxis = normalize(cross(v, up));
                     vec3 yaxis =  normalize(cross(v, xaxis));
                     vec3 center = v * imagePlane;
                     vec3 origin = center - (xaxis * (width  *.5)) - (yaxis * (height * .5));
                     return normalize(origin + (xaxis * coord.x) + (yaxis * (height - coord.y)));
                   }

     const vec4 K = vec4(1.0, .666666, .333333, 3.0);
     vec3 hsv2rgb(const vec3 c){
       vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
       return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
     }

     float distFunc(vec3 p){
       return distKlein(p);
     }

     const vec2 d = vec2(0.01, 0.);
     vec3 getNormal(const vec3 p){
       return normalize(vec3(distFunc(p + d.xyy) - distFunc(p - d.xyy),
                             distFunc(p + d.yxy) - distFunc(p - d.yxy),
                             distFunc(p + d.yyx) - distFunc(p - d.yyx)));
     }

     const float PI_4 = 12.566368;
     const vec3 LIGHTING_FACT = vec3(0.1);
     vec3 diffuseLighting(const vec3 p, const vec3 n, const vec3 diffuseColor,
                          const vec3 lightPos, const vec3 lightPower){
                            vec3 v = lightPos - p;
                            float dot = dot(n, normalize(v));
                            float r = length(v);
                            return (dot > 0.) ?
                                             (lightPower * (dot / (PI_4 * r * r))) * diffuseColor
                                                                  : LIGHTING_FACT * diffuseColor;
                          }

     const vec3 lightPos = vec3(400, 0, 500);
     const vec3 lightPos2 = vec3(-300., -300., -300);
     const vec3 lightPower = vec3(800000.);
     const vec3 lightPoweSPHERE_R2 = vec3(10000.);

     const int MAX_MARCHING_LOOP = 800;
     vec2 march(const vec3 origin, const  vec3 ray, const float threshold){
       vec3 rayPos = origin;
       float dist;
       float rayLength = 0.;
       for(int i = 0 ; i < MAX_MARCHING_LOOP ; i++){
         dist = distFunc(rayPos);
         rayLength += dist;
         rayPos = origin + ray * rayLength ;
         if(dist < threshold) break;
       }
       return vec2(dist, rayLength);
     }

     const vec3 BLACK = vec3(0);
     vec3 calcColor(vec3 eye, vec3 ray){
       vec3 l = BLACK;
       float coeff = 1.;
       vec2 result = march(eye, ray, 0.01);
       vec3 intersection = eye + ray * result.y;
       vec3 matColor = vec3(0);
       vec3 normal = getNormal(intersection);
       if(result.x < 0.01){
         matColor = hsv2rgb(vec3(0.1 + loopNum * 0.1 , 1., 1.));
         l += diffuseLighting(intersection, normal, matColor, lightPos, lightPower);
         l += diffuseLighting(intersection, normal, matColor, lightPos2, lightPower);
       }
       return l;
     }

     const float DISPLAY_GAMMA_COEFF = 1. / 2.2;
     vec3 gammaCorrect(vec3 rgb) {
       return vec3((min(pow(rgb.r, DISPLAY_GAMMA_COEFF), 1.)),
                   (min(pow(rgb.g, DISPLAY_GAMMA_COEFF), 1.)),
                   (min(pow(rgb.b, DISPLAY_GAMMA_COEFF), 1.)));
     }

     const vec3 eye = vec3(300 , 0., 850 );
     const vec3 target = vec3(0, 0, 0);
     const vec3 up = vec3(0, 1, 0);
     float fov = radians(60.);
     void main(){
       const vec2 coordOffset = vec2(0.5);
       vec3 ray = calcRay(eye, target, up, fov,
                          resolution.x, resolution.y,
                          gl_FragCoord.xy + coordOffset);

       gl_FragColor = vec4(gammaCorrect(calcColor(eye, ray)), 1.);
     }

    </script>
    <script id="indra-frag" type="x-shader/x-fragment">
     precision mediump float;
     uniform float time;
     uniform vec2  mouse;
     uniform vec2  resolution;

     const float MTL_PSEUDO_KLEINIAN = 1.;
     const float MTL_KLEIN = 2.;

     vec3 ROTATION_AXIS = normalize(vec3(0.1, 1, 0.5));

     vec3 rotate(vec3 p, float angle){
       float s = sin(angle);
       float c = cos(angle);
       float r = 1.0 - c;
       mat3 m = mat3(ROTATION_AXIS.x * ROTATION_AXIS.x * r + c,
                     ROTATION_AXIS.y * ROTATION_AXIS.x * r + ROTATION_AXIS.z * s,
                     ROTATION_AXIS.z * ROTATION_AXIS.x * r - ROTATION_AXIS.y * s,
                     ROTATION_AXIS.x * ROTATION_AXIS.y * r - ROTATION_AXIS.z * s,
                     ROTATION_AXIS.y * ROTATION_AXIS.y * r + c,
                     ROTATION_AXIS.z * ROTATION_AXIS.y * r + ROTATION_AXIS.x * s,
                     ROTATION_AXIS.x * ROTATION_AXIS.z * r + ROTATION_AXIS.y * s,
                     ROTATION_AXIS.y * ROTATION_AXIS.z * r - ROTATION_AXIS.x * s,
                     ROTATION_AXIS.z * ROTATION_AXIS.z * r + c);
       return m * p;
     }

     vec2 opUnion(const vec2 d1, const vec2 d2){
       return (d1.x < d2.x) ? d1 : d2;
     }

     const vec3 spherePos1 = vec3(5, 5, 0);
     const vec3 spherePos2 = vec3(5, -5, 0);
     const vec3 spherePos3 = vec3(-5, 5, 0);
     const vec3 spherePos4 = vec3(-5, -5, 0);
     const vec3 spherePos5 = vec3(0, 0, 7.071);
     const vec3 spherePos6 = vec3(0, 0, -7.071);
     const float SPHERE_R = 5.;
     const float SPHERE_R2 = SPHERE_R * SPHERE_R;

     int kleinIteration = 8;
     float kleinSphereR = 5.;
     float loopNum = 0.;
     const int SPHERE_NUM = 6;
     const vec3 KLEIN_POS = vec3(0, 0, -5);
     const int MAX_KLEIN_ITARATION = 20;
     const vec4 initialSp = vec4(-1.);
     vec2 distKlein(vec3 pos){
       pos = rotate(pos + KLEIN_POS, radians(time * 30.));
       loopNum = 0.;
       float dr = 1.;
       vec4 sp;
       for(int i = 0 ; i < MAX_KLEIN_ITARATION ; i++){
         if(i > kleinIteration) break;
         sp = initialSp;

         float d = distance(pos, spherePos1);
         sp = (d < SPHERE_R) ? vec4(spherePos1, d) : sp;
         d = distance(pos, spherePos2);
         sp = (d < SPHERE_R) ? vec4(spherePos2, d) : sp;
         d = distance(pos, spherePos3);
         sp = (d < SPHERE_R) ? vec4(spherePos3, d) : sp;
         d = distance(pos, spherePos4);
         sp = (d < SPHERE_R) ? vec4(spherePos4, d) : sp;
         d = distance(pos, spherePos5);
         sp = (d < SPHERE_R) ? vec4(spherePos5, d) : sp;
         d = distance(pos, spherePos6);
         sp = (d < SPHERE_R) ? vec4(spherePos6, d) : sp;

         if(sp.x == -1.){
           break;
         }else{
           vec3 diff = (pos - sp.xyz);
           dr *= SPHERE_R2 / dot(diff, diff);
           pos = (diff * SPHERE_R2)/(sp.w * sp.w) + sp.xyz;
           loopNum++;
         }
       }
       return vec2((length(pos) - kleinSphereR) / abs(dr) * 0.08, MTL_KLEIN);
     }


     vec3 orb;
     const vec3 PSEUDO_KLEINIAN_POS = vec3(10, 6, 2.5);
     const vec3 TRAP_POINT = vec3(1000.);
     const vec3 PSEUDO_KLEINIAN_CUBE_SIZE = vec3(9.2436, 9.0756, 9.2436);
     const float PSEUDO_KLEINIAN_SIZE = 110.;
     vec2 distPseudoKleinian(vec3 p){
       orb = TRAP_POINT;
       p = p + PSEUDO_KLEINIAN_POS;
       float DEfactor = 1.;
       vec3 ap = p + 1.;
       for(int i = 0; i < 7 ; i++){
         ap = p;
         p= -p + 2. * clamp(p, -PSEUDO_KLEINIAN_CUBE_SIZE, PSEUDO_KLEINIAN_CUBE_SIZE);
         orb = min( orb, vec3(abs(p)));
         float k = PSEUDO_KLEINIAN_SIZE / dot(p, p);
         p *= k;
         DEfactor *= k;
       }
       return vec2(abs(0.5*abs(p.z)/DEfactor), MTL_PSEUDO_KLEINIAN);
     }

     vec3 calcRay (const vec3 eye, const vec3 target, const vec3 up, const float fov,
                   const float width, const float height, const vec2 coord){
                     float imagePlane = (height * .5) / tan(fov * .5);
                     vec3 v = normalize(target - eye);
                     vec3 xaxis = normalize(cross(v, up));
                     vec3 yaxis =  normalize(cross(v, xaxis));
                     vec3 center = v * imagePlane;
                     vec3 origin = center - (xaxis * (width  *.5)) - (yaxis * (height * .5));
                     return normalize(origin + (xaxis * coord.x) + (yaxis * (height - coord.y)));
                   }

     const vec4 K = vec4(1.0, .666666, .333333, 3.0);
     vec3 hsv2rgb(const vec3 c){
       vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
       return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
     }

     vec3 eye = vec3(0, 0, 800);
     vec3 target = vec3(0, 0, 7);
     const vec3 up = vec3(0, 1, 0);
     float fov = radians(60.);

     vec2 distFunc(vec3 p){
       return opUnion(distPseudoKleinian(p), distKlein(p));;
     }

     const vec2 d = vec2(0.01, 0.);
     vec3 getNormal(const vec3 p){
       return normalize(vec3(distFunc(p + d.xyy).x - distFunc(p - d.xyy).x,
                             distFunc(p + d.yxy).x - distFunc(p - d.yxy).x,
                             distFunc(p + d.yyx).x - distFunc(p - d.yyx).x));
     }

     const float PI_4 = 12.566368;
     const vec3 LIGHTING_FACT = vec3(0.1);
     vec3 diffuseLighting(const vec3 p, const vec3 n, const vec3 diffuseColor,
                          const vec3 lightPos, const vec3 lightPower){
                            vec3 v = lightPos - p;
                            float dot = dot(n, normalize(v));
                            float r = length(v);
                            return (dot > 0.) ?
                                             (lightPower * (dot / (PI_4 * r * r))) * diffuseColor
                                                                  : LIGHTING_FACT * diffuseColor;
                          }

     const vec3 lightPos = vec3(100., 100., 100.);
     const vec3 lightPos2 = vec3(-100., -100., -100);
     const vec3 lightPower = vec3(10.);
     const vec3 lightPower2 = vec3(10.);

     vec3 lighting(const float kd, const vec3 matColor, vec3 l,
                   const vec3 intersection, const vec3 normal){
                     return (kd > 0.) ?
                   l + (diffuseLighting(intersection, normal, matColor,
                                        lightPos, lightPower) * kd) +
                                        (diffuseLighting(intersection, normal, matColor,
                                                         lightPos2, lightPower2) * kd)
                                                        : l;
                   }

     const int MAX_MARCHING_LOOP = 700;
     vec3 march(const vec3 origin, const  vec3 ray, const float threshold){
       vec3 rayPos = origin;
       vec2 dist = vec2(0., -1);
       float rayLength = 0.;
       for(int i = 0 ; i < MAX_MARCHING_LOOP ; i++){
         dist = distFunc(rayPos);
         rayLength += dist.x;
         rayPos = origin + ray * rayLength ;
         if(dist.x < threshold) break;
       }
       return vec3(dist, rayLength);
     }

     const float fogStart = 10.;
     const float fogEnd = 100.;
     const float FOG_END_START_RECIPROCAL = 1. / (fogEnd - fogStart);
     const vec3 fogf = vec3(1.);
     const vec3 BLACK = vec3(0);
     int reflectNum = 3;
     vec3 trace(vec3 eye, vec3 ray){
       vec3 l = BLACK;
       float coeff = 1.;
       for(int depth = 0 ; depth < 5 ; depth++){
         if(depth >= reflectNum) break;
         float threshold = 0.003 * pow(1.3 , float(depth));
         vec3 result = march(eye, ray, threshold);
         vec3 intersection = eye + ray * result.z;
         vec3 matColor = vec3(0);
         vec3 normal = getNormal(intersection);
         if(result.x < threshold){
           float ks = 0.;
           if(result.y == MTL_KLEIN){
             ks = (loopNum < 4.) ? 0.5 * coeff : 0.;
             matColor = hsv2rgb(vec3(0.1 + loopNum * 0.1 , 1., 1.));
           }else{
             matColor = vec3(clamp(6.0*orb.y,0.0,1.0), clamp(1.0-2.0*orb.z,0.0,1.0), .5);
             ks = (matColor.r > 0.8 &&
                   matColor.g > 0.8 ) ? 0.8 * coeff : 0.;
           }

           if(ks > 0.){
             l = mix(fogf , lighting(1. - ks, matColor, l, intersection, normal),
                     clamp((fogEnd - result.z) * FOG_END_START_RECIPROCAL, 0.5, 1.0));
             coeff = ks;
             eye = eye + ray * result.z * 0.9;
             ray = reflect(ray, normal);
           }else{
             l = mix(fogf , lighting(1. - ks, matColor, l, intersection, normal),
                     clamp((fogEnd - result.z) * FOG_END_START_RECIPROCAL, 0.5, 1.0));
             break;
           }
         }else{
           l = mix(fogf , l, clamp((fogEnd - result.z) * FOG_END_START_RECIPROCAL, 0.5, 1.0));
           break;
         }
       }
       return l;
     }

     void expandSphere(const float t,
                       const float minR, const float maxR, const int iteration){
                         kleinIteration = iteration;
                         kleinSphereR = mix(minR, maxR,
                                            smoothstep(minR, maxR, t));
                       }

     void shrinkSphere(const float t,
                       const float minR, const float maxR, const int iteration){
                         kleinIteration = iteration;
                         kleinSphereR = mix(maxR, minR,
                                            smoothstep(minR, maxR, minR + t));
                       }

     const float DISPLAY_GAMMA_COEFF = 1. / 2.2;
     vec3 gammaCorrect(vec3 rgb) {
       return vec3((min(pow(rgb.r, DISPLAY_GAMMA_COEFF), 1.)),
                   (min(pow(rgb.g, DISPLAY_GAMMA_COEFF), 1.)),
                   (min(pow(rgb.b, DISPLAY_GAMMA_COEFF), 1.)));
     }

     const float eyeRad = 8.9;
     void main(){
       float t = mod(time, 85.);
       const float minR = 0.;
       const float maxR = 3.;
       vec3 eye = vec3(eyeRad * sin(time), 0., 7. + eyeRad *  cos(time));
       target = -(eye - target ) + vec3(0. , (mouse.y - 0.5) * -10., 0);
       if(t < 3.){
         expandSphere(t, minR, maxR, 0);
       }else if(t < 6.){
         shrinkSphere(t - 3., minR, maxR, 0);
       }else if(t < 9.){
         expandSphere(t - 6., minR, maxR, 1);
       }else if(t < 12.){
         shrinkSphere(t - 9., minR, maxR, 1);
       }else if(t < 15.){
         expandSphere(t - 12., minR, maxR, 2);
       }else if(t < 18.){
         shrinkSphere(t - 15., minR, maxR, 2);
       }else if(t < 21.){
         expandSphere(t - 18., minR, maxR, 3);
       }else if(t < 24.){
         shrinkSphere(t - 21., minR, maxR, 3);
       }else if(t < 27.){
         expandSphere(t - 24., minR, maxR, 4);
       }else if(t < 30.){
         shrinkSphere(t - 27., minR, maxR, 4);
       }else if(t < 40.){
         expandSphere(t - 30., minR, 5., 12);
         reflectNum = 4;
       }else if(t < 55.){
         expandSphere(t - 40., 5., 6.3, 12);
         reflectNum = 4;
       }else if(t < 65.){
         shrinkSphere(t - 55., 2.0833, 6.5, 8);
       }else if(t < 70.){
         shrinkSphere(t - 65., minR, 2.0833, 8);
       }else if(t < 71.){
         kleinSphereR = 0.;
         kleinIteration = 7;
       }else if(t < 72.){
         kleinSphereR = 0.;
         kleinIteration = 6;
       }else if(t < 73.){
         kleinSphereR = 0.;
         kleinIteration = 5;
       }else if(t < 76.){
         kleinSphereR = 0.;
         kleinIteration = 4;
       }else if(t < 78.){
         kleinSphereR = 0.;
         kleinIteration = 3;
       }else if(t < 80.){
         kleinSphereR = 0.;
         kleinIteration = 2;
       }else if(t < 82.){
         kleinSphereR = 0.;
         kleinIteration = 1;
       }else{
         kleinSphereR = 0.;
         kleinIteration = 0;
       }
       const vec2 coordOffset = vec2(0.5);
       vec3 ray = calcRay(eye, target, up, fov,
                          resolution.x, resolution.y,
                          gl_FragCoord.xy + coordOffset);

       gl_FragColor = vec4(gammaCorrect(trace(eye, ray)), 1.);
     }

    </script>
    <script src="lib/jquery-1.12.0.min.js"></script>
    <script src="main.js" type="text/javascript"></script>
  </body>
</html>
